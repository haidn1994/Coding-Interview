# 정수론

컴퓨터의 동작과 이산 수학은 떼려야 뗄 수 없는 관계이기 때문에, 
이와 관련된 정수론에 관련된 문제들도 프로그래밍을 하면서 자주 마주하게 된다.  
따라서 가끔식 필요할 때가 있기 때문에 조금이라도 공부를 해두는 것이 좋다.  
이 장에서는 정수론에 관련된 가장 기초적인 알고리즘들을 소개한다.  

## 소수와 합성수

## 소수 판별법

```{.cpp}
// O(sqrt(n))시간에 동작하는 소수 판별 알고리즘

// 주어진 자연수 n이 소수인지 확인한다.
bool isPrime(int n){
	// 예외 처리: 1과 2는 예외로 처리한다.
	if(n <= 1)
		return false;
	if(n == 2)
		retrun true;

	// 2를 제외한 모든 짝수는 소수가 아니다.
	if(n % 2 == 0) 
		return false;
	
	// 2를 제외했으니 3 이상의 모든 홀수로 나누어보자.
	int sqrtn = int(sqrt(n));
	for(int div = 3; div <= sqrtn; div += 2)
		if(n % div == 0)
			return false;

	return true;
}
```
## 소인수 분해

## 에라토스테네스의 체

### 에라토스테네스의 체를 이용한 빠른 소인수 분해

## 유클리드 알고리즘

## 모듈라 연산

### 모듈라 덧셈, 뺄셈, 곱셈

### 모듈라 나눗셈

## 더 읽을거리

### 확장 유클리드 알고리즘

유클리드 알고리즘은 사실 한 수에서 다른 수를 빼는 과정을 반복하기 때문에, 유클리드 알고리즘gcd(p, q)을 수행하는 도중에 출현하는 모든 수는 p, q의 가중치 합은 a\*p + b\*q으로 쓸 수 있다.  
예를 들어 15와 6의 최대공약수를 구하는 과정은 다음과 같다.  

* gcd(6, 15) = gcd(9, 6) = gcd(3, 6) = gcd(3, 3) = gcd(0, 3) = 3

gcd(9, 6)에서의 9는 15-6이고, gcd(3, 6)에서의 3은 9-6 = (15-6)-6 = 15-2\*6이다.  
이 점을 이용하면 gcd(p, q)또한 항상 다음 형태로 쓸 수 있음을 알 수 있다.  

* gcd(p, q) = a\*p + b\*q

이 때 유클리드 알고리즘에 코드를 적절히 추가하여 최대 공약수와 함께 a, b를 반환하도록 할 수 있다.  
이와 같은 알고리즘을 확장 유클리드 알고리즘(Extended Euclidean algorithm)이라고 부른다.  


### 중국인 나머지 정리

오래된 중국 수학채에서 처음 등장했다고 해서 이런 이름이 붙은 중국인 나머지 정리(Chinese Remaninder Theorem)는 다음과 같은 형태의 문제를 풀 수 있게 해준다.  


n개의 사과를 세 명이 나누어 먹으려고 했는데 각자 같은 개수의 사과를 갖고 나서 두 개가 남았다.  
한 명을 더 불러 네 명이 나누어 먹으려고 했는데 세 개가 남았다.  
한 명을 더 불러 다섯 명이 나누어 먹으려고 했는데 하나가 남았다. 최소의 n은 얼마인가?  


이 문제의 답은 중국인 나머지 정리를 이용하면 확장 유클리드 알고맂믕르 통해 구할 수 있다.  

### 루카스의 정리

루카스의 정리(Lucas's Theorem)는 모듈라 연산을 이용한 이항 계수 C(n, r)을 빠르게 구할 수 있게 해 주는 정리로써,  
모듈라 연산을 이용하지 않을 경우엔 계산하기 어려울 정도로 큰 n과 r에 대해 이항 계수를 계산할 수 있도록 해 준다.  

