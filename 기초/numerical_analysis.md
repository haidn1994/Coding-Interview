# 수치 해석

수치 해석은 직접 풀기 힘든 수학 문제를 근사적으로 푸는 알고리즘과 이들의 수치적 안전성,  
오차의 범위 등을 연구하는 전산학의 한 분야로, 공학, 과학, 금융공학 등 다양한 범위에 널리 사용된다.  
현업에서는 해당 분야에서 일하는 것이 아니라면 볼 일은 적겠지만, 기초적인 몇 가지 알고리즘은 자주 유용하게 사용된다.  

## 이분법과 이분법의 정의

수치해석에서 유명한 방법을 하나 꼽아보자면, 바로 이분법이다.  
이분법은 이진탐색과도 밀접한 연관이 있기 때문에 친숙하며, 유용하게 널리 사용된다.  


이분법은 주어진 범위 [lo, hi]내에서 어떤 함수 f(x)의 값이 0이 되는 지점을 수치적으로 찾아내는 기법이다.  
f(x)가 단조 함수가 아니고, 답이 여러개가 있는 함수(삼각함수, 실근을 여러개 가지는 2차이상의 다항함수 등)더라도,  
연속이기만 하더면 이분법을 사용해 근을 찾을 수 있다.  


이분법을 사용하기 위해서는 우선 함수의 그래프 상에서 x축 윗부분에 위치한 점 하나와 아랫부분에 위치한 점 하나를 찾아야 한다.  
그래프가 연속인 경우, 중간값 정리에 의해 이 두 점 사이에서 그래프가 x축을 만나는 지점이 반드시 존재한다.  
이제 이분법을 구현하는 것은 간단하다. lo와 hi의 중간점에서 f(x)의 값을 검사한다.  
따라서 [lo, hi]구간 내에도 답이 존재한다는 것을 알 수 있다.  
이제 hi = mid로 갱신하고 처음으로 돌아가서 반복하면 된다.  
이렇게 이분법은 매 반복마다 [lo, hi]구간의 크기를 절반으로 줄여나간다.  
구간의 크기가 각 단계마다 절반씩 줄어들기 때문에, 굉장히 빨리 답으로 수렴하는 것을 알 수 있다.  

#### 참고

bisection()은 반복문이 모두 종료한 후에는 답의 후보 구간의 중간 값을 반환한다.  
반복문 불변식에 의하면 우리가 원하는 답은 [lo, hi]에 있는데,  
이 중 최대 오차를 최소화할수 있는 답이 중간 값이기 때문이다.  

```{.cpp}
double f(double x);
// 이분법의 예제 구현

double bisection(double lo, double hi){
	// 반복문 불변식을 강제한다.
	if(f(lo) > 0)
		swap(lo, hi);

	// 반복문 불변식 f(lo) <= 0 <f(hi)
	while(fabs(hi - lo) > 2e - 7){
		double mid = (lo + hi) / 2;
		double fmid = f(mid);

		if(fmid <= 0)
			lo = mid;
		else
			hi = mid;
	}

	// 가운데 값을 반환한다.
	return (lo + hi) / 2;
}
```

### 절대 오차를 이용한 종료 판정

이분법에서 가장 중요한 부분은 바로 while문의 종료 조건이다.  
while문을 많이 수행할수록 오차가 줄어들 테지만, 알고리즘을 영원히 수행할 수 없는 노릇이니  
우리는 정확도와 수행 속도 사이에서 적절히 타협하는 종료 조건을 선택해야 한다.  
그러나 모든 경우에 안정적으로 동작하도록 이분법의 종료 조건을 선택하기란 놀랍도록 어렵다.  

### 상대 오차를 이용한 종료 판정

이와 같이 절대 오차를 사용하는 방법은 다루는 값의 크기가 작을 때는 훌륭하게 동작하지만 값의 크기가 커지면 문제가 생길 수 있다.  
부동 소수점은 가부수라고 부르는 정수 부분과 이 변수에서 소수점의 위치를 나타내느 지수부(exponent)의 조합으로 표현되기 때문에,  
표현할 수 있는 수의 집합이 제한되어 있다. 따라서 숫자의 절대 값이 커지면 커질수록 표현할 수 있는 수들이 듬성듬성해지게 된다.  


다음 코드는 이 현상에서 오는 문제를 보여준다. lo와 hi는 2 * 10^-5정도 차이가 나기 때문에 금방 종료될 것 같지만,  
여기서 lo와 hi사이에는 double변수가 포함할 수 있는 값이 하나도 없다. 따라서 lo와 hi는 같은 값이 된다.  
따라서 이 함수는 절대로 종료 되지 않는다.

```{.cpp}
void infiniteBisection(){
	double lo = 123456123456.1234588623046875;
	double hi = 123456123456.1234741210937500;
	while(fabs(hi - lo) > 2e-7)
		hi = (lo + hi) / 2.0;
	printf("finished!\n");
}
```
이런 문제를 극복하기 위해서는 절대 오차말고도 상대 오차를 허용하여 이분법의 값 범위를 측정한다.  
상대오차를 적용하면 위와 같은 일은 벌어지지 않지만, 구현이 복잡하기 때문에 경험이 풍부한 사람들은 이런 방법을 쓰지 않는다.  

### 정해진 횟수만큼 반복하기

단순해 보이지만 가장 유용한 방법은 while문을 적당한 for문으로 대체해서 반복문이 항상 정해진 횟수만큼 실행되도록 하는 것이다.  
예를 들어 반복문을 100번 수행하면 반환하는 답의 절대 오차는 |lo - hi|/2^101이 된다.  
따라서 큰 숫자를 다루는 경우에도 충분히 답을 두할 수 있다. 또한 이와 같은 방버은 절대로 무한 반복에 빠지지 않으며,  
프로그램의 최대 수행 시간을 예상하기도 쉽다는 장점이 있다. 반복문 내부를 100번 수행할 수 있는가만 확인하면 되니까...

### 삼분 검색

이분법이 매 반복마다 답의 후보 구간을 절반으로 잘라 각 위치에서 함수의 값을 계산하는 것과 비슷하게,  
삼분 검색은 답의 후보 구간을 삼등분 하는 두 위치에서 함수의 값을 계산한다.  


삼분 검색을 사용하기 위해서는 이분법과 비슷하게 최대치를 포함하는 후보 구간을 우선 알고 있어야 한다.  
이 구간을[lo, hi]라고 하자. 그러면 이 구간을 삼등분 하는 위치는 각각 2-lo+hi/3, lo+2-hi/3이 된다.  
이제 각 위치에서 함수의 값을 계산한다.  

삼분 검색은 이와 같이 한 번 반복할 때마다 후보 구간의 크기를 2/3로 줄여나간다.  
다음 코드에서 삼분 검색의 구현을 볼 수 있다. 이분법에서 그랬듯 이 반복분을 100번 수행하는 것을 볼 수 있다.  
삼분 검색에서는 구간의 크기가 매 반복마다 2/3으로 줄어들기 때문에 구간의 길이는 |hi - lo|\*(2/3)^n이 된다.  
100번 수행하고 나면 대개의 경우 충분히 정확한 값을 얻을 수 있다.  

```{.cpp}
// 우리가 최대치를 찾고 싶어하는 함수
double f(double x);

// [lo, hi]구간에서 f(x)가 최대치를 갖는 x를 반환한다.
double ternary(double lo, double hi){
	for(int iter = 0; iter < 100; iter++){
		double a = (2*lo + hi) / 3.0;
		double b = (lo + 2*hi) / 3.0;

		if(f(a) > f(b))
			hi = b;
		else
			lo = a;
	}

	return (lo+hi) \ 2.0;
}
```

### 왜 삼분 검색을 쓰나?

어떤 함수의 최대점을 찾는 문제를 생각해 보자.  
함수를 미분할 수 있다면 도함수 값이 0인 점들을 하나하나 시도해 봐도 되고,  
국소 탐색같은 알고리즘을 써도 된다. 하지만 여기에 비해 삼분 검색이 가지는 강점이 있다.  


삼분 검색은 미분할 수 없는 함수에도 사용할 수 있으며,  
국소 탐색에 비해 훨씬 빠르게 동작하고 수렴 판정에 용이하기 때문에 이런 방법보다 훨씬 자주 사용하게 된다.  


삼분 검색으로 쉽게 풀어낼 수 있는 문제를 하나 보이자면,  
오목 함수의 최대치를 구하는 문제나 볼록 함수의 최소치를 구하는 작업은 삼분 검색의 요구 조건을 거의 만족한다.  
방금 전 설명에서 볼록/오목 함수가 삼분 검색의 요구 조건을 '거의' 만족한다는 말이 무슨 뜻일까?  
이들 함수에는 *수평선*이 존재할 수 있다는 이야기이다.  
오목 함수와 볼록 함수의 성질 중 하나는 이 두 함수의 수평선이 있을 수 있는 부분은 최소, 최대점뿐이기 때문이다.  
삼분 검색의 후보 범위가 수평선 내에 들어오더라도,  
이미 모든 후보가 최소, 최대치를 포함한다면 상관없이 항상 정답을 구할 수 있다.  
따라서 볼록, 오목 함수의 최대, 최소치를 찾는 문제는 항상 삼분 검색을 이용해 풀 수 있다.  






























































































