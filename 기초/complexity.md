# 알고리즘의 시간 복잡도 분석

복잡한 Big-O의 정의는 잠시 내버려두고, 실용적으로 시간 복잡도에 대해서 알아보자.  
어떤 알고리즘의 수해이간을 지배하는 것은 바로 반복문이다.  
입력의 크기에 상관없이 항상 같은 수행 시간을 갖는 알고리즘도 있지만,  
대개는 입력의 크기에 따라 수행 횟수가 정해지는 반복문이 있기 마련이다.  
입력의 크기가 커지면 커질수록 반복문이 알고리즘의 수행시간을 지배하게 된다.  


따라서 우리는 대체로 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정한다.  
이 때 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현한다.  


예를 들어, 주어진 배열에서 가장 많이 등장하는 수를 찾는 다음 코드1 을 보도록 한다.  
이 알고리즘의 수행 시간은 배열의 크기 N에 따라 변한다. N번 수행되는 반목문이 두 개 겹쳐져 있으므로,  
반복문의 가장 안쪽은 항상 N^2번 실행된다. 따라서 이 알고리즘의 수행 시간은 N^2이다.  


```{.cpp}
// 주어진 배열 A에서 가장 많이 등장하는 숫자를 반환한다.  
// 만약 두가지 이상 있다면 아무것이나 반환한다.
int majority(const vector<int>& A){
	int N = A.size();
	int majority = -1, majorityCount = 0;

	for(int i = 0; i < N; ++i){
		// A에 등장하는 A[i]의 수를 센다.
		int V = A[i], count = 0;
		for(int j = 0; j < N; ++j){
			if(A[j] == V){
				++count;
			}
		}

	// 지금까지 본 최대 빈도보다 많이 출현했다면 답을 갱신한다.
		if(count > majorityCount){
			majorityCount = count;
			majority = V;
		}
	}

	return majority;
}
```

입력으로 100점이 만점인 어떤 시험점수라고 하자.  
이처럼 숫자의 범위가 작다면 배열을 이용해서 각 숫자가 등장하는 횟수를 쉽게 셀 수 있다.
그리고 마지막에 빈도수 배열을 순회하면서 최대치의 위치를 찾으면 된다. 이것을 구현한것이 코드2이다.  
이 코드에는 반복문이 2개 있다. 
하나는 N번 수행되고 다른 하나는 100번 수행되므로 전체 반복문의 수행 횟수는 N + 100이 된다.  
그런데 N이 커지면 커질수록 사실 후자의 반복문은 수행 시간에서 차지하는 비중이 줄어들게 된다.  
따라서 궁극적으로는 이 알고리즘의 수행 시간은 N이라고 쓴다. 

```{.cpp}
// A의 각 원소가 0부터 100사이의 값일 경우 가장 많이 등장하는 숫자를 반환한다.  
int majority2(const vector<int>& A){
	int N = A.size();
	vector<int> count(101, 0);
	for(int i = 0; i < N; ++i){
		count[A[i]]++;
	}

	// 지금까지 확인한 숫자 중 빈도수가 제일 큰 것을 majority에 저장한다.  
	int majority = 0;
	for(int i = 1; i <= 100; ++i){
		if(count[i] > count[majority]){
			majority = i;
		}
	}

	return majority;
}

```
