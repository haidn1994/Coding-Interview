/*
    다이나믹 프로그래밍은 이름만 보고 정확히 무슨 뜻인지 알 수 없는데,
    이는 작명이 잘못되었기 때문이다.

    이는 동적 계획법(Dynamic Programming) 단어의 창시자 벨만(Richard E. Bellman)이
    당시 벨 연구소에 재직중이던 dynamic이란 단어가 멋있기도 하고, 
    연구소 펀딩 받기에 좋은 단어라서 선택했다고 한다.
	
	여기에 더해 프로그래밍(programming)이라는 용어도 프로그래머가 생각하는 프로그래밍과 뜻이 다르다.
	Programming이라는 용어는 최적화 연구 분야에서 최적의 프로그램을 찾아낸다는 의미로 사용된다.
	참고로 벨만은 '수학자'였는데 벨만이 사용한 "Programming"의 뜻은 이 의미였을 것이다.
	이제 작명에 얽힌 이야기는 잠시 접어두고 동적 계획법에 대해서 공부해보자.

	동적 계획법은 특정한 방법(구체적인 알고리즘)을 뜻한다기 보다는, 문제를 해결하는 패러다임을 일컫는다.
	동적 계획법은 주어진 문제를 문제 해결에 용이하게 작은 문제들로 나눈 뒤,
	각 작은 문제들의 답을 계산하고, 이 답을 통해서 원래 문제의 답을 구하는 방식을 뜻한다.
	사실 분할 정복이나 재귀 함수를 통한 문제 해결과 넓은 의미에서 접근 방식은 같지만
	작은 답을 구하는 과정(문제를 나누는 과정)에서 메모이제이션(Memoization)을 사용하는 점이 
	다른 방식과 두드러지는 차이점이라 할 수 있다.

	그럼 메모이제이션[1]은 무엇일까?
	위에서 언급한 각 작은 문제들의 답을 구할 때 
	각각의 작은 문제의 답은 다른 작은 문제(부분 문제라고도 한다.)를 구할 때 유용하게 사용가능하다.
	따라서 그 작은 문제의 답을 기억해(메모) 두었다가. 
	다른 문제를 풀때 그 답을 사용하면(재활용) 어떤 문제를 풀 때 걸리는 시간이 확 줄어든다.

	다시 말해서 시간 복잡도를 줄이기 위해서 공간을 더 사용하고, 
	시간 복잡도를 획기적으로 단축하는 방법, 또는 이런 최적화 기법을 메모이제이션이라고 한다.

	여기서 이미 계산하여 얻은 작은 문제의 답을 재활용할 의도로 
	메모리에 저장한 장소를 캐시(cache)라고 부른다.
	또한 두 번 이상 계산되는 작은 문제(부분 문제)를 
	중복되는 부분 문제(overlapping subproblems)라고 부른다.

	요약하자면 동적 계획법은 두 번 이상 반복되는 부분 문제의 답을 미리 저장하여,
	속도의 향상을 꾀하는 알고리즘 설계 기법을 동적 계획법이라고 한다.
	이 과정에서 핵심적으로 사용하는 최적화 기법은 메모이제이션이다.

	한마디 더 추가하자면 '동적 계획법'이라는 단어보다는 
	'기억하며 풀기'라는 단어가 더 와닿을 것이다. 
	용어에 거부감이 느껴진다면 대신 이 단어를 받아들이는 것을 추천한다.

	동적 계획법을 이해하는 가장 쉬운 예시는 피보나치 수열을 재귀 함수로만 구하는 프로그램과
	동적 계획법을 적용한 피보나치 수열을 구하는 프로그램을 작성하여 
	두 프로그램의 실행결과를 비교하는 것이다.

	다음 예제에서는 피보나치 수열의 일반항을 동적 계획법을 적용하여 빠르게 구하는 것을
	보여주는 프로그램이다.
 */

#include <stdio.h>

#define ARRAY_SIZE 94

int call_count = 0;

// 간단한 예제니까 typedef는 지양한다.
// C언어에서 초기화 하지 않은 인덱스의 값은 전부 0으로 초기화된다.
unsigned long long memo[ARRAY_SIZE] = {0, 1, }; // 수열의 0번째 수와 1번째 수는 미리 저장해 둔다.

unsigned long long fibo(int n)
{
	count++;

	unsigned long long fibo_number; // 수열의 값을 표현할 지역변수이다.

	if(!n || memo[n]) 			// 이미 계산해서 알고 있는 피보나치 수열의 n항이라면
		fibo_number = memo[n];	// 메모리에서 꺼내 돌려준다.
	else {						// 이 항을 계산한 적이 없다면
		memo = fibo(n-1) + fibo(n-2);	// 계산한 후에 memo에 기억한다.
		fibo_number = fibo(n-1) + fibo(n-2);
	}

	return fibo_number;
}

int main(void) {
	int n;

	printf("0항 부터 93항까지의 피보나치 수열을 
			동적 계획법을 적용하여 계산 하도록 설계되었다.\n");
	printf("참고로 0항은 1이고 1항은 1이다. 
			구현의 편의를 위하여 이렇게 만들었으니 양해 바란다.\n");

	printf("알고 싶은 항을 입력하시오:\n");
	scanf("%d", &n);
	printf("%llu \n", fibo(n));

	printf("함수 호출 회수: %d", call_count);

	return 0;
}
/*
   
	[1] "메모리제이션, 메모라이제이션(Memorization) 아닙니까? 왜 철자를 틀리는 거죠?"
	라고 물어보지 말라. 메모리를 사용하는 것은 사실이지만 메모에 초점이 맞춰진 단어다.
	
    출처:

    프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 1권 207p ~ 211p - 구종만 

	한글, 영어 위키백과 - 동적 계획법
	https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95
	https://en.wikipedia.org/wiki/Dynamic_programming	

    나무위키 - 동적 계획법 문서
	https://namu.wiki/w/%EB%8F%99%EC%A0%81%20%EA%B3%84%ED%9A%8D%EB%B2%95#fn-1

	나무위키 - 메모이제이션
	https://namu.wiki/w/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98


 */


