/*
	조합은 점화식으로 표현하여 그 값을 구할 수 있을 뿐만 아니라. 이렇게 점화식으로 표현하여 얻을 수 있는 이점도 상당하다.
	그 이점 중 하나가 바로 오버플로우 에러 방지다. 조합을 일반항을 통해서 구하면 가장 빠르게 구할 수 있다는 장점이 있지만,
	n!/k!*(n-k)!를 구하기 위해서 컴퓨터는 반드시 계승함수의 값을 구해야 한다. 이는 정수의 표현범위를 쉽게 넘을수 있기 때문에 정확한 결과값을 얻기 어렵다.

	그리고 점화식 표현하면 생각나는 게 있지 않은가? 바로 피보나치 수열이다.
	피보나치 수열을 코드를 통해 구현하는 방법이 바로 점화식 표현이다.
	따라서 조합의 점화식 표현을 알고, 기저조건(basis condition)을 익히면 조합도 코드로 표현할 수 있다.
	조합의 점화식 표현은 다음과 같다.
	C(n, k) = C(n-1, k-1) + C(n-1, k)
	그리고 조합의 성질은 다음과 같다.
	1. C(n, 0) = C(n, n) = 1
	2. C(n, 1) = n

	자, 이제 코드를 작성해볼 시간이다!

 */

#include <stdio.h>

int combination(int n, int k)
{
	return (k == n || k == 0) ? 1 :
		   (k == 1) ? n : combination(n-1, k-1) + combination(n-1, k);
}

int main(void)
{
	int a = combination(7, 0);
	int b = combination(10, 1);
	int c = combination(11, 5);

	printf("a:%d b:%d c:%d\n", a, b, c);

	return 0;
}
// 잘 작동하지만 계산량이 너무 많다.(재귀 호출) 동적 계획법을 사용해서 개선해 보도록 한다.
