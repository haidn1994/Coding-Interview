#재귀 호출의 이해와 활용

앞서 설명했던 "함수의 이해"(call_by_something_exam.c)를 잘 보고 공부했다면,  
함수 내부에서 함수를 호출하는 것도 얼마든지 가능하다는 사실을 알 수 있을 것이다.
그러나, 잘 이해가 되지 않았을 가능성도 있기에 재귀호출을 처음부터 공부해보도록 한다.  

##재귀함수: 왜 사용하는가?

사실 재귀함수는 쓸일이 많지는 않지만 (너무나도 당연하게) 동작 방식을 잘 이해하고,  
언제 어디서 유용한지 잘 알고 있다면 비교적 짧고 간결한 코드로 하고자하는 일을 할 수 있다.
여기서 잠시 재귀함수는 왜 짧고 간결한 코드를 만드는데 유용한지 알아보자.  

함수가 특히 많이 쓰이는 수학의 수식을 코드로 거의 흡사하게 표현할 수 있어서 사용한다.  
...정도로만 이해하고 있어도 괜찮지만(물론 뒤에서 말할 내용과 이어지는 내용이다.) 더 구체적으로 말해보자면,  
프로그래밍을 공부하다보면 동적 계획법(Dynamic Programming),  
분할 정복(Divide and Conquer)와 같은 문제 해결 전략, 방법을 나타내는 단어를 만나게 된다.    
이런 방법의 주된 요지는 해결하고자 하는 문제를 작은 단위로 쪼개고 나누어 하나하나 해결한 다음,  
그 결과를 다시 합쳐서 원래 풀고자 했던 문제를 해결하는 것을 말한다.  


이 때, 작은 단위로 여러가지를 생각해 볼 수 있지만  
이 용도에 특히 유용하게 사용할 수 있는 프로그래밍 요소가 바로 **함수**이다.  
함수가 문제를 해결할 수 있을 수준까지 자신을 재귀적으로 호출하여 문제를 충분히 작은 단위로 나누고  
그 함수들이 각자 내놓는 반환값을 적절히 합친다면 비교적 적은 수고를 들이고 문제를 해결할 수 있지 않겠는가? 
(제대로, 적재적소에 만들었다면 보기쉽고, 간결하고, 오류 수정이 용이한 코드를 얻을 수 있을 것이다.)   


하지만 함수는 프로그래머가 보다 쉽게 프로그래밍을 할 수 있도록 만든 고수준의 문법이다.  
즉, 비교적 큰 오버헤드를 수반하는 프로그래밍 언어의 문법이라는 뜻이다.  
물론 일상적으로 함수를 호출하고 사용하는 정도로는 거의 오버헤드를 느낄 수 없지만,  
재귀적으로 호출하여 문제를 해결하려고 하면 얼마나 함수가 호출되는가에 따라서 스택 오버플로로 프로그램이 종료되어 버릴 수도 있고,  
한꺼번에 스택이 넘칠정도로 함수가 많이 호출되지 않는다고 해도,  
많은 함수가 수행되는 과정에서 문맥 전환(Context Switch)이 수없이 일어나서 결과적으로 느린 프로그램이 만들어진다.  


이런 이유 때문에 "현업에서 결코 재귀함수를 사용하지 않을꺼야!"라고 마음먹더라도  
재귀함수를 배우고 활용하는 과정에서 분명히 배울 수 있는 점이 많이 있을것이라 생각한다.  
앞서 말한 "크고 어려운 문제를 많고 작은 문제로 쪼개어 해결하는 방법"을 배우는데 가장 좋은 방법중 하나이다.  
또한 재귀 함수도 몇가지 최적화 기법을 적용하고, 처음부터 빠른 알고리즘을 채택하여 만든다면 결코 느리지 않다.  

##간단한 예제부터 시작하자.
시작하기 전에 재귀함수가 가져야 하는 전형적인 구조에 대해서 알아보겠다.  
재귀함수는 문제를 해결할수 있을 때까지 자기 자신을 호출하는(코드를 복사하여 스택 프레임에 올리는)구조를 가지고 있는데,  
이 "문제를 해결 할 수 있을 때"는 더이상 "함수를 단위로 문제를 쪼갤 수 없을 때"로 이해 할 수 있다.  
이 때 더이상 쪼개지지 않는 단위를 **기저 사례(base case)**[2]라고 한다.  
여기에 더해서 재귀함수에 들어갈수 있는 모든 입력이 기저 사례를 활용해서 계산될 수 있도록 해야한다.  


이제 가장 유명한 예제인 팩토리얼부터 시작해 보겠다.  
아래는 재귀함수로 표현한 n!이다.  

```{.c}
long long recur_factorial(int n)
{
	return (n == 0) ? 1 /*기저 사례*/ : n * recur_factorial(n-1);
}
```

이 함수의 기저사례는 n이 1일 경우이다.  
factorial(1)은 더이상 자신을 호출하지 않고 즉각 1을 반환하도록 설계되었으며,  
해당 프로세스의 스택 세그먼트는 factorial(1)이 할당된 스택 프레임을 기준으로 차례로 하나씩 반납된다.


여기에 몇 가지 더 알아보자면, 이 함수는 자신을 호출할때 한번에 한개씩 호출한다.  
즉 스택에 데이터가 쌓이는 속도가**선형적**으로 증가한다. => 빅-오는 O(n)  
이는 문제를 해결 할 때 필요한 함수 호출 횟수가 그렇게 많지 않다는 뜻으로 받아들일 수 있고,  
스택에 데이터를 쌓아올려서 생기는 오버헤드도 그다지 크지 않다는 뜻으로 이해 할 수 있다.  
다만 팩토리얼 함수는 n을 조금만 키워도 반환값이 폭발적으로 증가하기 때문에   
큰 정수를 표현하는 내장 라이브러리가 없는 C에서는 큰 값을 표현하기 곤란하다.  

TIP: 사실 팩토리얼처럼 데이터 처리가 쉽게 표현되면,  
굳이 부분문제로 나누고 할 이유도 딱히 없다.  
따라서 오버헤드가 적어도 재귀함수를 쓰지 말고 반복문으로 해결하기를 추천한다.  


다음은 스택 프레임이 쌓이는 속도가 **비선형적**으로 증가하는 피보나치 수열의 재귀적 구현에 대해서 알아보겠다.  

##피보나치 수열

```{.c}
unsigned long long fibo(int n)
{
	if(n == 1)
		return 0;
	else if(n == 2)
		return 1;
	else
		return fibo(n-1) + fibo(n-2);
}
```

"이 함수는 기저 사례가 2개 아닙니까?"라고 생각할 수도 있지만  
잘 생각해보자, 처음부터 fibo(1)을 호출한게 아니라면 해당 분기문으로 분기하는 경우가 없다.  
따라서 기저 사례는 n = 2일때이다.


하지만 정말 중요한 점은 피보나치 수열의 재귀적 구현은 함수를 한번 호출할때 마다,  
최대 2개씩 자기 자신을 호출한다는 점이다.  
그리고 문제를 해결하기 위해 호출된 함수의 호출 횟수를 세기 위해  
함수 호출 정보를 하나씩 따라가 이를 표현하기 위한 그림을 그려보면 다음과 같은 그림을 얻을 수 있다.  


앞서 말한 팩토리얼은 함수 호출 정보를 선형적으로 표현할 수 있는 것과는 다르게,
fibo()의 함수 호출 정보는 *비선형적* 자료구조인 **트리**(그 중에서도 이진 트리)로 표현된다는 사실을 알 수 있다.  
이는 fibo()가 문제를 해결하기 위해 함수를 호출할 때 fibo(3), fibo(4)등의 값을 계산해서 기억한 다음 활용하지 못하고  
각각의 함수 호출에 대하여 필요한 기저 사례를 찾을 때까지 중복적으로 끊임없이 계산을 수행한다는 사실을 보여준다.  
다시 말해서, 인자 n이 커질수록 필요한 함수 호출 횟수가 지수적으로 증가한다. 


=>  빅-오는 O(2^n), 사실 진짜 시간복잡도는 1.6^n정도 된다고 한다.


이렇게 성능 문제때문에 재귀함수를 사용하기 곤란한 경우,  
사용하기 적합한 최적화 기법/기술중 하나가 메모이제이션이다.  
또한 이런 문제에 효과적으로 대응하기 좋은 알고리즘 설계 패러다임이 있는데,  
위에서 설명한 동적 계획법과 분할 정복법이다.  


이제 재귀에 익숙해졌는가?  
하지만 아직 재귀에 좀 더 익숙해질 필요가 있다.  
한 가지 주제만 더 보고 이 글을 마치도록 하겠다.  


##참고 문헌

###서적

* 열혈강의 자료구조[1] - 윤성우
* 알고리즘 문제해결 전략[2] - 구종만
* 문제로 풀어보는 알고리즘[3] - 김용혁, 황인욱

###웹 페이지

* 재귀 함수의 오버헤드: http://www.nicklib.com/application/2953
* 재귀의 문제점: http://itance.tistory.com/entry/%EC%9E%AC%EA%B7%80%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90
* 피보나치 재귀 구현의 시간복잡도: http://stackoverflow.com/questions/360748/computational-complexity-of-fibonacci-sequence

