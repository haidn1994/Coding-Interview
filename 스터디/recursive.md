#재귀 호출의 이해와 활용

앞서 설명했던 "함수의 이해"(call_by_something_exam.c)를 잘 보고 공부했다면,  
함수 내부에서 함수를 호출하는 것도 얼마든지 가능하다는 사실을 알 수 있을 것이다.
그러나, 잘 이해가 되지 않았을 가능성도 있기에 재귀호출을 처음부터 공부해보도록 한다.  

##재귀함수: 왜 사용하는가?

사실 재귀함수는 쓸일이 많지는 않지만 (너무나도 당연하게) 동작 방식을 잘 이해하고,  
언제 어디서 유용한지 잘 알고 있다면 비교적 짧고 간결한 코드로 하고자하는 일을 할 수 있다.
여기서 잠시 재귀함수는 왜 짧고 간결한 코드를 만드는데 유용한지 알아보자.  

함수가 특히 많이 쓰이는 수학의 수식을 코드로 거의 흡사하게 표현할 수 있어서 사용한다.  
...정도로만 이해하고 있어도 괜찮지만(물론 뒤에서 말할 내용과 이어지는 내용이다.) 더 구체적으로 말해보자면,  
프로그래밍을 공부하다보면 동적 계획법(Dynamic Programming),  
분할 정복(Divide and Conquer)와 같은 문제 해결 전략, 방법을 나타내는 단어를 만나게 된다.    
이런 방법의 주된 요지는 해결하고자 하는 문제를 작은 단위로 쪼개고 나누어 하나하나 해결한 다음,  
그 결과를 다시 합쳐서 원래 풀고자 했던 문제를 해결하는 것을 말한다.  


이 때, 작은 단위로 여러가지를 생각해 볼 수 있지만  
이 용도에 특히 유용하게 사용할 수 있는 프로그래밍 요소가 바로 **함수**이다.  
함수가 문제를 해결할 수 있을 수준까지 자신을 재귀적으로 호출하여 문제를 충분히 작은 단위로 나누고  
그 함수들이 각자 내놓는 반환값을 적절히 합친다면 비교적 적은 수고를 들이고 문제를 해결할 수 있지 않겠는가? 
(제대로, 적재적소에 만들었다면 보기쉽고, 간결하고, 오류 수정이 용이한 코드를 얻을 수 있을 것이다.)   


하지만 함수는 프로그래머가 보다 쉽게 프로그래밍을 할 수 있도록 만든 고수준의 문법이다.
즉, 비교적 큰 오버헤드를 수반하는 프로그래밍 언어의 문법이라는 뜻이다.
물론 일상적으로 함수를 호출하고 사용하는 정도로는 거의 오버헤드를 느낄 수 없지만  
재귀적으로 호출하여 문제를 해결하려고 하면 얼마나 함수가 호출되는가에 따라서 스택 오버플로로 프로그램이 종료되어 버릴 수도 있고,  
한꺼번에 스택이 넘칠정도로 함수가 많이 호출되지 않는다고 해도,  
많은 함수가 수행되는 과정에서 문맥 전환(Context Switch)이 수없이 일어나서 결과적으로 느린 프로그램이 만들어진다.  


이런 이유 때문에 "현업에서 결코 재귀함수를 사용하지 않을꺼야!"라고 마음먹더라도  
재귀함수를 배우고 활용하는 과정에서 분명히 배울 수 있는 점이 많이 있을것이라 생각한다.  
앞서 말한 "크고 어려운 문제를 많고 작은 문제로 쪼개어 해결하는 방법"을 배우는데 가장 좋은 방법중 하나이다.  
또한 재귀 함수도 몇가지 최적화 기법을 적용하고, 처음부터 빠른 알고리즘을 채택하여 만든다면 결코 느리지 않다.  

##간단한 예제부터 시작하자.
시작하기 전에 재귀함수가 가져야 하는 전형적인 구조에 대해서 알아보겠다.  
재귀함수는 문제를 해결할수 있을 때까지 자기 자신을 호출하는(코드를 복사하여 스택 프레임에 올리는)구조를 가지고 있는데,  
이 "문제를 해결 할 수 있을 때"는 더이상 "함수를 단위로 문제를 쪼갤 수 없을 때"로 이해 할 수 있다.
이 때 더이상 쪼개지지 않는 단위를 **기저 사례(base case)**[2]라고 한다.  
여기에 더해서 재귀함수에 들어갈수 있는 모든 입력이 기저 사례를 활용해서 계산될 수 있도록 해야한다.  


이제 가장 유명한 예제인 팩토리얼부터 시작해 보겠다.  
아래는 재귀함수로 표현한 n!이다.  

```{.c}
long long recur_factorial(int n)
{
	return (n == 0) ? 1 /*기저 사례*/ : n * recur_factorial(n-1);
}
```






##참고 문헌

###서적

* 열혈강의 자료구조[1] - 윤성우
* 알고리즘 문제해결 전략[2] - 구종만
* 문제로 풀어보는 알고리즘[3] - 김용혁, 황인욱

###웹 페이지

* 재귀 함수의 오버헤드: http://www.nicklib.com/application/2953
* 재귀의 문제점: http://itance.tistory.com/entry/%EC%9E%AC%EA%B7%80%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90


